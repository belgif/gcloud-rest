== Versioning ==

[CAUTION]
.Don’t Break Backward Compatibility 
====
Change APIs, but keep all consumers running. Consumers usually have independent release lifecycles, focus on stability, and avoid changes that do not provide additional value. APIs are service contracts that cannot be broken via unilateral decisions.
====

There are two techniques to change APIs without breaking them:

* follow rules for compatible extensions
* introduce new API versions and still support older versions

We strongly encourage using compatible API extensions and discourage versioning. With Postel’s Law in mind, here are some rules for providers and consumers that allow us to make compatible changes without versioning:

=== Prefer Compatible Extensions ===

Apply the following rules to evolve RESTful APIs in a backward-compatible way:

* Ignore unknown fields in the payload
* Add only optional, never mandatory fields
* Never change the meaning of a field.
* Enum ranges cannot not be extended when used for output parameters — clients may not be prepared to handle it. However, enum ranges can be extended when used for input parameters.
* Enum ranges can be reduced when used as input parameters, only if the server is ready to accept and handle old range values too. Enum values can be reduced when used as output parameters.
* Support redirection in case an URL has to change (301 Moved Permanently)


=== Always Return JSON Objects As Top-Level Data Structures To Support Extensibility === 

In a response body, you must always return a JSON objects (and not e.g. an array) as a top level data structure to support future extensibility. JSON objects support compatible extension by additional attributes. This allows you to easily extend your response and e.g. add pagination later, without breaking backwards compatibility.
